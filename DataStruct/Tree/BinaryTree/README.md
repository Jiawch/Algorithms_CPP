## 二叉树
### 1 二叉树的特性
- 节点数与边数：一棵二叉树有n个元素，n > 0，则它有m = n - 1条边。
- 已知高度求节点数：一棵二叉树的高度为h，h ≥ 0，则它最少有h个元素，最多有2<sup>h</sup>-1个元素。   
   第i层最多有2<sup>i-1</sup>个节点。
- 已知节点数求高度：一棵二叉树有n个节点，n > 0，则它的最大高度为n，最小高度为log<sub>2</sub>(n+1)的上取整 或者 log<sub>2</sub>n 下取整 +1。
- 完全二叉树的下标：（计算机对整数会自动下取整）  
  1. 当下标是1开始时，第i个节点的父节点为i/2，左孩子为2\*i，右孩子为2\*i+1
  2. 当下标是0开始时，第i个节点的父节点为(i-1)/2，坐孩子为2\*i+1，右孩子为2\*i+2

### 2 二叉树的实现
- 数组实现  
  1. 完全二叉树适合用数组实现
  2. [数组实现的二叉树](./arrayBinaryTree.h)   
    - T searchNode(int theIndex)：根据索引（数组下标）寻找节点
    - void addNode(int theIndex, int direction, T \*pNode): 添加节点，theIndex是待插入节点的父节点的索引（数组下标），direction = 0代表左子树，direction = 1代表右子树，pNode是待插入的值
    - void deleteNode(int theIndex, T \*pNode)：删除节点，将被删除的节点放到pNode中返回
    - void treeTrave()：遍历节点  

- 链表实现  
  1. 非完全二叉树适合用链表实现
  2. [链表实现的二叉树](./linkedBinaryTree.h)  
    - bool empty()：判断树是否为空
    - int size()：树的节点数
    - T\* rootElement()：返回根节点的值
    - void makeTree(const T& element, linkedBinaryTree<T>&, linkedBinaryTree<T>&)：给定根节点、左子树和右子树，创建一块新的树
    - linkedBinaryTree<T>& removeLeftSubtree()：删除并返回左子树
    - linkedBinaryTree<T>& removeRightSubtree()：删除并返回右子树
    - void **preOrder**()：先序遍历
    - void **preOrderUnRecursive**()：先序遍历（非递归版本）
    - void **inOrder**()：中序遍历
    - void **inOrderUnRecursive**()：中序遍历（非递归版本）
    - void **postOrder**()：后续遍历
    - void **postOrderUnRecursive**()：后序遍历（非递归版本）
    - void **levelOrder**()：层次遍历
    - [int **height**()](./treeDepth.cpp)：树的高度（约定，树高相关的题尽量从高度为自然数）

### 3 二叉树的遍历
- 前序遍历  
  1. 递归版本：先访问根节点，再递归访问左子树、右子树。递归的终止条件是树为空。
  2. 非递归版本：对于任一节点，其可看做是根节点，因此可以直接访问，访问完之后，若其左孩子不为空，按相同规则访问它的左子树；当访问完其左子树时，再访问它的右子树。（用栈实现）
- 中序遍历  
  1. 递归版本：先递归访问左子树，再访问根节点，最后递归访问右子树。递归的终止条件是树为空。
  2. 非递归版本：对于任一节点，优先访问其左孩子，而左孩子节点又可以看做一根节点，然后继续访问其左孩子节点，直到遇到左孩子节点为空的节点才进行访问，然后访问其右子树。（用栈实现）
- 后序遍历  
  1. 递归版本：先递归访问左子树，然后递归访问右子树，最后访问根节点。递归的终止条件是树为空。
  2. 非递归版本：对于任一节点P，如果P不存在左孩子和右孩子，则可以直接访问它；或者P存在左孩子或者右孩子，但是其左孩子和右孩子都已被访问过了，则同样可以直接访问该节点。（用栈实现）
- 层次遍历  
  层次遍历是一层一层访问树的节点，可以用队列来实现
- 前序遍历、中序遍历和后序遍历的非递归实现对比
  1. 三者相同的都是在p指针为空且栈为空是退出循环。
  2. 外圈while循环内前一步不断寻找到最左的孩子的方法基本相同。
  3. 不同的主要在p指针为空需要出栈后的操作：
    - 先序遍历是在前面寻找最左孩子时就已经visit节点，后面出栈后是直接让指针p指向出栈节点的右孩子；
    - 中序遍历在后面出栈时，先visit出栈的节点，再让指针p指向出栈的节点的右孩子；
    - 后序遍历多了个pre指针指向前一个visit过的节点；出栈前需要检查确保栈顶节点的右孩子为空或者被visit过 才能出栈visit该出栈的节点，如果栈顶节点的右孩子不为空且还没被visit过 就不出栈 让p指针p指向栈顶元素的右孩子。


[二叉树的4种遍历](./order.cpp)

### 4. 复杂度分析
- 时间复杂度
   1. 对于图，深度优先遍历的复杂度为O(n + m)，其中n是节点数，m是边数。
   2. 二叉树是特殊图，先中后序遍历都是DFS，所以复杂的为O(n+n-1)=O(n).
   3. 公式推导法
   ```
   T(n) <= 2T(n/2) + 1, T(1) = 1;
   T(n) <= 2 (2T(n/4)+1) + 1 = 4T(n/4) + 3;     ==> 2^2 T(n/2^2) + 2^2-1
   T(n) <= 4 (2T(n/8)+1) + 3 = 8T(n/4) + 7;     ==> 2^3 T(n/2^3) + 2^3-1
   T(n) <= 8 (2T(n/16)+1) + 7 = 16T(n/16) + 15; ==> 2^4 T(n/2^4) + 2^4-1
   ...
   T(n) <= nT(1) + (n-1) = n + (n-1)
   ```
- 空间复杂度
   1. 空间复杂度看树度深度或者递归树度深度，最好为平衡二叉树O(logn), 最坏为斜树O(n).
   2. 公式推导法
   ```
   T(n) = T(n/2) + 1, T(1) = 1;
   T(n) = T(n/4)+1 + 1 = T(n/4) + 2;   ==> T(n/2^2) + 2
   T(n) = T(n/8)+1 + 2 = T(n/8) + 3;   ==> T(n/2^3) + 3
   ...
   T(n) = T(1) + logn
   ```
