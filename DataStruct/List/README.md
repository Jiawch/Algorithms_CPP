
### 线性表的数组描述和单向链表描述的注意事项
- 数组描述
  - 如果我们总是按一个乘法因子来增加数组长度（如：乘法因子是2），那么实施一系列线性表的操作所需要的时间与不用改变数组长度时相比，至多增加一个常数因子。（STL vector中的乘法因子是1.5）
  - 通常我们让当线性表元素个数n等于数组元素个数时，数组长度加倍，当线性表元素个数n等于数组元素个数的1/4时，数组长度减半
- 链表描述
  - 线性表的链表描述通常有：带头结点 和 不带头结点两种
  - 对于没有头结点的链表，进行插入和删除操作时，要注意判断插入或删除的结点是不是首结点


### 线性表数组实现和链表实现操作的空间和时间复杂度对比
- 空间复杂度：
假设一个数组元素或链表结点中数据元素部分的内存大小为s个字节，线性表元素个数为n
 - 使用数组描述线性表，且当线性表元素个数n等于数组元素个数时，数组长度加倍，当线性表元素个数n等于数组元素个数的1/4时，数组长度减半，则具有n个元素的线性表，可以存储在一个长度为n~4n之间的数组中，即用数组描述线性表所需要的内存大小为：**ns ~ 4ns个字节**
 - 使用链表描述线性表，n个元素恰好分配了n个结点，每个结点有两个域，其中一个是数据域，大小为s个字节，一个是指针域，大小为4字节，即用链表描述线性表所需要的内存大小为：**n(s+4)个字节**

  因此，大多数的应用设计在选择线性表的描述方法时，空间复杂度上的差异并不是决定性因素

- 时间复杂度：<br />
操作|数组实现|链表实现
:---:|:---:|:---:
get|O(1)|O(n)
indexOf|O(n)|O(n)
insert|O(n)|O(n)
erase|O(n)|O(n)

 - 在很多操作上，虽然线性表的数组描述和链表描述的时间复杂度上都是O(n)，但是在数组中移动是顺序访问内存，而在链表中移动是随机访问内存，在实际中，数组的顺序访问内存使得数组描述的线性表在各种操作上都要比链表描述的线性表要快得多。
 - 另外，对于同样是线性表，创建链表的过程是顺序的链表的 各种操作 也要比 创建过程是随机的链表 要快得多。

### 带头结点的双向循环链表
- 进行indexOf时，可以重复利用头结点来简化代码。首先将要查找的元素放在头结点，然后从首节点开始进行查找，最终肯定能找到，但是如果找到的位置是头结点，则说明链表中不存在该元素。
- 用虚构函数销毁循环链表是，一定要先将最后一个结点的指针置空(firstNode->previous->next = NULL)，否则会引起内存泄露，程序异常。
  因为循环链表的最后一个结点的next指针指向头结点，当头结点被销毁时，该next指针将指向未知的空间，因此当析构函数销毁到最后一个结点后，仍然会沿着最后一个结点的next指针继续消耗，而此时这个next指针却是指向未知的空间，这时会对内存中未知的区域进行破坏。

### STL中的链表
- vector：相当于数组实现的线性表 
- list：相当于链表实现的线性表

### 代码实现
[线性表的抽象数据类型](./linearList.h)<br />
[数组描述的线性表](./arrayList.h)<br />
[链表描述的线性表](./chainList.h)<br />
[带头结点的双向循环链表](./circularListWithHeader.h)<br />








