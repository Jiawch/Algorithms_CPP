<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>
###1 字典描述

 - 有序数组描述
 - 有序链表描述
 - 哈希表描述

###2 字典的哈希表描述    
####2.1 哈希函数
 - 最常用的哈希函数是除法哈希函数：f(k) = k % D 。其中，k是关键字，D是哈希表的长度，%是取模操作符。
 - 选择除法哈希函数时，D的选择十分重要，有些会产生良好的哈希函数，有些会产生不良的哈希函数。<br />合理的除数D应该既不是偶数又不能是被2~19之间的数整除，理想的D还应该是一个素数。

####2.2 冲突处理

#####2.2.1 线性探测
 - 使用线性探测时，哈希表是一个环形表。
 - 线性探测的插入、查找和删除操作  
  1. 插入：将用哈希函数对pair的关键字做哈希运行，得到关键字对应的桶的编号。此时，如果桶没有被占用，则将该pair放到桶中；如果该桶已经被占用，则向后查找还没有被占用的桶。
  2. 查找：假设要查找关键字为k的数对，首先搜索起始桶f(k)，然后把哈希表当做环表继续搜索下一个桶，直到以下情况发生为止：1)存在关键字k的桶已找到，即找到了要查找的数对； 2)到达一个空桶，没有找到； 3)又回到起始桶f(k)，没有找到。
  3. 删除：删除哈希表元素不能破坏哈希表的结构。删除哈希表中的数对时，要从删除位置的下一个桶开始，逐个检查每个桶，以确定要移动的元素，直至到达一个空桶或者回到删除的位置为止。在做删除移动时，一定要注意，不要把一个数对移到它的起始桶之前，否则，对这个数对的查找就可能失败。

 - 性能分析   
设b为哈希表的桶数，D为哈希函数的除数，且b=D。当所有关键字都对应在同一个起始桶是，便是最坏情况。
令U_n和S_n分别表示在一次成功搜索和不成功搜索中的平均搜索的桶数。则：<br />
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<img src="http://www.forkosh.com/mathtex.cgi? \Large U_{n} \approx \frac{1}{2}(1+\frac{1}{(1-a)^2})"><br />
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<img src="http://www.forkosh.com/mathtex.cgi? \Large S_{n} \approx \frac{1}{2}(1+\frac{1}{1-a})">  
$$ U_{n} \approx \frac{1}{2}(1+\frac{1}{(1-a)^2}) $$  
$$S_{n} \approx \frac{1}{2}(1+\frac{1}{1-a})$$  
<img src="http://chart.googleapis.com/chart?cht=tx&chl=\Large x=\frac{-b\pm\sqrt{b^2-4ac}}{2a}" style="border:none;">
其中a = n/b为负载因子。  
当a=0.5时，一次不成功的搜索将平均查找2.5个桶，一次成功的搜索将平均查找1.5个桶；当a=0.9时，这些数字分别为50.5和5.5。当然这假定n>>51。<br >
当负载因子a比较小时，哈希表的平均性能比线性表的平均性能要好得多。  

 - 为何不使用随机探测？  
使用随机探测确实能减少查看桶的数目，但是实际中真正影响运行时间的不是要查看的桶数，计算一个随机数比查看若干个桶更需要时间。另外，线性探测还能充分利用缓存。

#####2.2.2 链式散列
 - 把每一个桶都设置为有序链表
 - 性能分析  
 从平均性能上看，使用链式散列时要检查的节点数比使用线性探测和随机探测都要少。如当a = 0.9时，在链式散列中，一次不成功搜索平均要检查9个节点，而一次成功搜索平均要检查1.45个结点。在线性探测中，这两个数是50.5和5.5。然而链表一样难以利用缓存。


###3 有序数组、有序链表、哈希表
| 方法 | 查找<br />（最坏情况） | 插入<br />（最坏情况） | 删除<br />（最坏情况） | 查找<br />（平均情况） | 插入<br />（平均情况） | 删除<br />（平均情况） |
|:---|:---:|:---:|:---:|:---:|:---:|:---:|
|有序数组|O(logn)|O(n)|O(n)|O(logn)|O(n)|O(n)|
|有序链表|O(n)|O(n)|O(n)|O(n)|O(n)|O(n)|
|哈希表|O(n)|O(n)|O(n)|O(1)|O(1)|O(1)|



###4 代码实现  
[字典的抽象数据类型](./dictionary.h)  
[字典的有序链表描述](./sortedChain.h)  
[字典的哈希表描述（线性探测）](./hashTable.h)  
[字典的哈希表描述（链式散列）](./hashChain.h)  

###5 C++ STL的哈希函数  
[hash](http://www.cplusplus.com/reference/functional/hash/?kw=hash)：根据传入的参数的不同，产生不同的哈希值。通常传入同一个参数返回相同的哈希值。

