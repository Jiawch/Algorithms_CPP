###冒泡排序
 - 概述：使用一种“冒泡策略”把最大元素移到序列最右端。在一次冒泡过程中，相邻的元素比较。如果左边的元素大于右边的元素，则交换。
 - 提前终止：一趟冒泡过程中，如果没有元素交换位置，则算法终止。

###选择排序
 - 概述：首先，找到数组中最小的那个元素，然后将它和数组的第一个元素交换位置（如果第一个元素就是最小元素，那么它就和自己交换）。再次，在剩下的元素中找到最小的元素，将它和数组的第二个元素交换位置。如此反复，直到整个数组排序。
 - 特点：
   1. 对于长度为N的数组，选择排序需要进行N^2/2次比较和N次交换。
   2. 运行时间与输入数据的分布无关，即一个原本有序数组或者主键全部相同的数组和一个元素排列的数组所用的排序时间是一样的。
   3. 只进行了N次交换，在所有的排序算法中，交换次数是最少的。

###插入排序
 - 概述：从左到右对每一个元素执行插入操作。在第i步插入中，将当前元素插入到前i-1个元素中的适合位置，并将插入位置之后的所有元素右移一位。
 - 特点：
   1. 插入排序所需的时间取决于输入中元素的初始顺序，当初始顺序已经为有序时，插入排序的的时间复杂度为O(N)
   2. 当排序数据比较少时，插入排序比其它排序算法都要快。比如：5 ~ 15

###希尔排序
 - 概述：希尔排序是插入排序的一种改进，每次交换不相邻的元素以对数组的局部进行排序，并最终用插入排序将局部有些的数组排序

###归并排序
 - 概述：
   1. 自顶向下的归并排序：递归。先将数组分成两半分布排序，然后将结果归并起来。
   2. 自底向上的归并排序：迭代。对所有元素先进行两两归并，然后是四四归并，然后八八归并，一直下去。在每一轮归并中，最后一次归并的第二个子数组可能比第一个子数组要小，如果不是的话所有的归并中两个数组大小都应该一样，而在下一轮中子数组的大小会翻倍。
 - 优化：
   1. 使用插入排序处理小规模的子数组，一般可以将归并排序的运行时间缩短10%~15%
   2. 在使用辅助数组b的时候，不进行每一轮都借助b来归并然后拷贝会a，而是轮流地将元素从a归并到b，从b归并到a，从而减少从b到a的拷贝过程。

###快速排序

###堆排序

###排序算法比较
算法|是否稳定|是否原地排序|时间复杂度|空间复杂度|备注
:---:|:---:|:---:|:---:|:---:|---
冒泡排序|否|是|N^2|1|
选择排序|否|是|N^2|1|
插入排序|是|是|介于N和N^2之间|1|取决输入元素的排列情况
希尔排序|否|是|NlogN? N^6/5?|1|
归并排序|是|否|NlogN|n|使用一个与原数组大小相等的辅助数组
快速排序|否|是|NlogN|logN|快速排序需要一个栈空间来实现递归，该递归栈的最大深度为logN
三向快速排序|否|是|介于N和NlogN之间|logN|
堆排序|否|是|NlogN|1|


###C++STL和Java Arrays.sort()

###排序算法运行时间比较




