###冒泡排序
 - 概述：使用一种“冒泡策略”把最大元素移到序列最右端。在一次冒泡过程中，相邻的元素比较。如果左边的元素大于右边的元素，则交换。
 - 提前终止：一趟冒泡过程中，如果没有元素交换位置，则算法终止。
 - code：[冒泡排序](./bubbleSort.h) &ensp; [提前终止的冒泡排序](./bubbleSort.h)

###选择排序
 - 概述：首先，找到数组中最小的那个元素，然后将它和数组的第一个元素交换位置（如果第一个元素就是最小元素，那么它就和自己交换）。再次，在剩下的元素中找到最小的元素，将它和数组的第二个元素交换位置。如此反复，直到整个数组排序。
 - 特点：
   1. 对于长度为N的数组，选择排序需要进行N^2/2次比较和N次交换。
   2. 运行时间与输入数据的分布无关，即一个原本有序数组或者主键全部相同的数组和一个元素排列的数组所用的排序时间是一样的。
   3. <front color=#FF0000>只进行了N次交换，在所有的排序算法中，交换次数是最少的。</front>
 - code：[选择排序](./selectionSort.h)

###插入排序
 - 概述：从左到右对每一个元素执行插入操作。在第i步插入中，将当前元素插入到前i-1个元素中的适合位置，并将插入位置之后的所有元素右移一位。
 - 特点：
   1. 插入排序所需的时间取决于输入中元素的初始顺序，当初始顺序已经为有序时，插入排序的的时间复杂度为O(N)
   2. <front color=#FF0000>当排序数据比较少时，插入排序比其它排序算法都要快。</front>比如：5 ~ 15
 - code：[插入排序](./insertSort.h)

###希尔排序
 - 概述：希尔排序是插入排序的一种改进，每次交换不相邻的元素以对数组的局部进行排序，并最终用插入排序将局部有些的数组排序
 - code：[希尔排序](./shellSort.h)

###归并排序
 - 概述：
   1. 自顶向下的归并排序：递归。先将数组分成两半分布排序，然后将结果归并起来。
   2. 自底向上的归并排序：迭代。对所有元素先进行两两归并，然后是四四归并，然后八八归并，一直下去。在每一轮归并中，最后一次归并的第二个子数组可能比第一个子数组要小，如果不是的话所有的归并中两个数组大小都应该一样，而在下一轮中子数组的大小会翻倍。
 - 优化：
   1. 使用插入排序处理小规模的子数组，一般可以将归并排序的运行时间缩短10%~15%
   2. 在使用辅助数组b的时候，不进行每一轮都借助b来归并然后拷贝会a，而是轮流地将元素从a归并到b，从b归并到a，从而减少从b到a的拷贝过程。
 - code：[归并排序(递归版本)](./mergeSortRecursion.h) &ensp; [归并排序(迭代版本)](./mergeSortIteration.h)

###快速排序
 - 概述：快速排序把n个元素划分为3段：左段left、中段middle、右段right。其中：中段只有一个元素，左段元素都不大于中段元素，右端元素都不小于中段元素。可以分别递归地对左段和右端进行排序且不用归并，当左段和右端都有序时，整个数组就都有序了。
 - 特点：
  1. <front color=#FF0000>快速排序是最快的通用排序算法。</front>它之所以快是因为它的内循环中指令很少（而且它还能利用缓存，因为它总是顺序地访问数据），它的运行时间的增长数量级为~cNlogN，而这里的c比其他线性对数级别的排序算法的相应常数都要小。
  2. 在使用三向切分之后，快速排序对于有大量重复元素的排序任务时间复杂度可能降到线性级别，而其他算法则仍然需要线性对数时间。
 - 优化：
  1. 使用插入排序处理小规模的子数组
  2. 在实际的应用中经常会出现含有大量元素的数组，这时使用三向快速排序，可以使线性对数级别的性能提高到线性级别
  3. 当输入数据基本有序时，快速排序的的时间复杂度达到最差情况，接近N^2，可以通过对输入元素乱序，使得输入数据不会基本有序。
 - code：[快速排序](./quickSort.h) &ensp; [三向切分快速排序](./quickSort3Way.h)

###堆排序
 - 概述：堆排序分为两个阶段：堆的构造阶段 和 下沉排序阶段。
   1. 在堆的构造阶段，将原始数组重新组织成大顶堆。
   2. 在下沉排序阶段，不断将堆顶元素（最大元素）和堆的最后一个元素交换位置，并让堆的大小减1；如此反复，数组将变得有序（从小到大）。
 - 优化：
   1. <front color=#FF0000>堆排序是唯一能够同时最优利用空间和时间的方法——在最坏的情况下它也能保证使用~2NlogN次比较和恒定的额外空间，当空间十分紧张时它很流行。</front>
   2. 然而堆排序无法利用缓存，数组元素很少和相邻的其它元素进行比较，因此缓存命中率远远低于大多数比较都在相邻元素间的算法，如快速排序、归并排序，甚至希尔排序。
 - code：[堆排序](./heapSort.h)


###排序算法比较
算法|是否稳定|是否原地排序|时间复杂度|空间复杂度|备注
:---:|:---:|:---:|:---:|:---:|---
冒泡排序|否|是|N^2|1|
选择排序|否|是|N^2|1|在所有的排序算法中，交换次数是最少的。
插入排序|是|是|介于N和N^2之间|1|取决输入元素的排列情况<br />当排序数据比较少时，插入排序比其它排序算法都要快。
希尔排序|否|是|NlogN? N^6/5?|1|
归并排序|是|否|NlogN|n|使用一个与原数组大小相等的辅助数组
快速排序|否|是|NlogN|logN|快速排序需要一个栈空间来实现递归，该递归栈的最大深度为logN
三向快速排序|否|是|介于N和NlogN之间|logN|当存在大量重复元素时，三向快速排序的时间复杂度接近于线性级别
堆排序|否|是|NlogN|1|较好利用时间和空间，但无法利用缓存


###C++STL和Java Arrays.sort()
 - C\+\+
C\+\+ STL中使用了改变的快速排序，当排序算法的子序列数量超过对数logN的某个常数倍时，使用堆排序，在数据段不大时，使用插入排序。
 stable_sort函数使用归并排序，但是当数据段不大时，使用插入排序
 - Java
 Java的Arrays.sort()对原始数据类型使用(三向切分的)快速排序，对引用类型使用归并排序。
 对于引用类型，Java用速度和空间来换取稳定性。

###排序算法运行时间比较
[code](compareSort.cpp)
![](./compareSort.png)




