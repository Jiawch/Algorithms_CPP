## 复杂度分析

- 时间复杂度：指执行当前算法所消耗的时间

- 空间复杂度：指执行当前算法需要占用的（临时）内存空间  
  *算法执行所需要的临时空间随着某个变量n的大小而变化*

### 一、常见的复杂度

| 大O记发 | 非正式术语 |
|:---:|:---:|
| O(1)   | 常数阶    |
| O(logn)| 对数阶    |
| O(n)   | 线性阶    |
| O(nlogn)| 线性对数阶|
| O(n<sup>2</sup>)| 平方阶 |

### 二、时间复杂度

#### 1. 常数阶O(1)
无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)，如：
```
int i = 1;      // 执行一次
int j = 2;      // 执行一次
int m = i + j;  // 执行一次
```

#### 2. 对数阶O(logn)
```
int i = 1;      // 执行一次
while(i <= n) {   // 执行logn次
    i = i * 2;  // 执行logn次
}
```
当i>n时，循环停止。也就是说少个2相乘后其结果值会大于n，即2<sup>x</sup>=n。那么x = log<sub>2</sub>n

#### 3. 线性阶O(n)
```
for(int i = 1; i <= n; i++) {
   j = i;
   j++;
}
```
这段代码，for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，因此这类代码都可以用O(n)来表示它的时间复杂度。

#### 4. 线性对数阶O(nlogn)
线性对数阶O(nlogN) 其实非常容易理解，将时间复杂度为O(logn)的代码循环N遍的话，那么它的时间复杂度就是 n * O(logN)，也就是了O(nlogN)。

就拿上面的代码加一点修改来举例：
```
for(int m = 1; m < n; m++) {
    int i = 1;
    while(i < n) {
        i = i * 2;
    }
}
```

#### 5. 平方阶(n<sup>2</sup>)
平方阶O(n²) 就更容易理解了，如果把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²) 了
```
for(int x = 1; i <= n; x++) {
   for(int i = 1; i <= n; i++) {
       j = i;
       j++;
    }
}
```
这段代码其实就是嵌套了2层n循环，它的时间复杂度就是 O(n\*n)，即 O(n²) 

### 三、空间复杂度

#### 1. 常数阶O(1)

如果算法执行所需要的临时空间不随着某个变量n的大小而变化，即此算法空间复杂度为一个常量，可表示为 O(1)
```
int i = 1;
int j = 2;
int m = i + j;
```
代码中的 i、j、m 所分配的空间都不随着处理数据量变化，因此它的空间复杂度为O(1)

#### 2. 线性阶O(n)
```
int[] m = new int[n]
for(int i = 1; i <= n; i++) {
   j = i;
   j++;
}
```
这段代码中，第一行new了一个数组出来，这个数据占用的大小为n，这段代码的其他行，虽然有循环，但没有再分配新的**与某个变量大小而变化的**空间，因此，这段代码的空间复杂度主要看第一行即可，即O(n)

### 四、利用递归树进行复杂度等理解



### Reference
> [*算法的时间与空间复杂度（一看就懂*）](https://zhuanlan.zhihu.com/p/50479555)
> 
> [*快速排序最好，最坏，平均复杂度分析*](https://blog.csdn.net/weshjiness/article/details/8660583)
